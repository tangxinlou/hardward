# clk
- 功能
设置s3c2440的始终为400mhz，察看循环亮灯的速度
- 实现
自己写一个汇编程序start.S
自己写一个c程序led.c
自己建立一个引脚.h 文件，里面把引脚的指针通过宏控设置简洁
start.S: 关掉看门狗，自动判断启动方式设置栈 调用main函数 ，死循环 

# uart
- 功能：
设置uart，使用串口传送一个字节的信息
- 实现
自己写一个汇编程序start.S
自己写一个c程序led.c
自己建立一个引脚.h 文件，里面把引脚的指针通过宏控设置简洁
建立一个main函数，可以控制发送字符串和接受字符
建立一个uart.c文件，包括初始化串口，发送和接收一个字节，另外发送一个字符串
建立一个uart.h文件把uart.c文件的函数申明包含
start.S: 关掉看门狗，自动判断启动方式设置栈 调用main函数 ，死循环 

# nor flash
 
- 功能
nor flash 有一个读时序，读时序的时间有要求，所以需要查看具体的数据右侧，查看需要的
寄存器配置,例如在发出读命令后，数据线的数据有效需要一个最短的时间是20ns，当前nor使用的100mhz的hclk，所以一个clk的时间是1000/100=10ns，我们所有的时间设置成70ns足以满足要求，所以设置成7个clk时钟
- 实现
自己写一个汇编程序start.S
自己写一个c程序led.c
自己建立一个引脚.h 文件，里面把引脚的指针通过宏控设置简洁
建立一个main函数，用来接收串口发送的字符，把字符和‘0’相减得到数字，然后设置clk数
建立一个uart.c文件，包括初始化串口，发送和接收一个字节，另外发送一个字符串
建立一个uart.h文件把uart.c文件的函数申明包含
建立一个init.c文件，把时间设置成相应的clk数
start.S: 关掉看门狗，自动判断启动方式设置栈 调用main函数 ，死循环 

# 重定位代码，commit 信息和课程对应

- 第一课
把数据段保存在0x800处，在makefile文件中用ld 链接指令直接指定。引入段的概念，相应变量保存在哪个段
commit 段的概念，全局变量的保存 
- 第二课
把0x800 改成0x30000000 ，这样会造成bin文件300多兆
- 第三课
1、不使用ld命令直接指令相应段的位置，而是使用lds链接脚本放置相应的.o文件中的相应段。但是必须指定加载地址，不然加载地址默认等于链接地址，导致bin依然300多兆
2、直接指定加载地址和运行地址，把数据段重定位到sdram，直接定位加载地址和运行地址略显粗笨
commit 使用粗笨的方法重定位了全局变量，解决nor 无法重新赋值全局变量的问题
- 第四课
使用宏控获取加载地址，使用lds变量代表运行地址，在汇编代码中通过ldrb 和strb指令将数据段重定位到sdram
commit 使用链接脚本中的加载地址和链接运行地址重定位全局变量的数据段
- 第五课
bss段保存的全是初始化为0或者没有初始化的全局变量，程序会统一把bss段清零（赋值成0）。为了看bss的值，实现了一个可以16进制打印int的uart 函数，并打印了保存在bss段中的初值为0的g_A
commit 测试打印16进制的4个字节数据函数
commit 实现十六进制打印一个存储空间的4个字节数据的函数
- 第六课
在汇编代码中清零了bss段
commit 清除bss段
- 第七课
strb 和ltrb 访问硬件次数太多，通过str 和ldr 指令降低访问次数，另外str是4字节指令，需要将bss在lds链接脚本中使用. = ALIGN(4) 四字节对齐
commit 使用str ldr 指令读写数据降低硬件访问次数，同时将bss段4自己对齐
- 第八课
使用结合式的链接脚本，通过指定代码段运行地址为30000000的方式，将整个代码和数据段都重定位到sdram
commit 使用结合式链接脚本设定整个链接运行地址30000000
- 第九课
通过汇编代码传参方式实现c语言的重定位和清除函数
commit 使用C语言拷贝代码，和清除bss
- 第十课
不需要汇编传参，直接在c语言中使用链接脚本中的变量，并讲解了C语言的中的变量和链接脚本中的变量保存在编译器符号表中的格式
commit c语言中获取和使用链接脚本中的变量











